本项目主要是用于自己个人的学习，方便在后期学习的过程中复习。\n
本文的主角就是“递归”，同时我们会从如下三方面来说明递归

###### 1.什么是递归？

###### 2.递归算法思路通用解决思路

###### 3.实战演练（从初级到高阶）

**什么是递归**

简单的说就是，如果在函数中存在着函数调用函数本身的情况，这种现象就叫递归。

以阶乘函数为例，在factorial函数中存在着factorial（n-1）的调用，所以此函数是递归函数

```java
public int factorial(int n){ 
	if(n <= 1){
		return 1;
	}
   return n* factorial(n-1);
}
```

进一步剖析「递归」，先有「递」再有「归」，「递」的意思就是将问题拆解成子问题来解决解决，子问题再拆解成子子问题,...,直到被拆解的子问题无需再拆分成更细的子问题（即可以求解），「归」是说最小的子问题解决了，那么它的上一层子问题也就解决了，上一层的子问题解决了，上上层子问题也就解决了,...,直到最开始的问题解决，文字说明可能有点抽象，那么我们以阶乘的图例说明下「递」和「归」。

![image-20200120141856893](C:\Users\myang\AppData\Roaming\Typora\typora-user-images\image-20200120141856893.png)

求解问题 f(6), 由于 f(6) = n * f(5), 所以 f(6) 需要拆解成 f(5) 子问题进行求解，同理 f(5) = n * f(4) ,也需要进一步拆分,... ,直到 f(1), 这是「递」，f(1) 解决了，由于 f(2) =  2 f(1) = 2 也解决了,.... f(n)到最后也解决了，这是「归」，所以递归的本质是能把问题拆分成具有**相同解决思路**的子问题，。。。直到最后被拆解的子问题再也不能拆分，解决了最小粒度可求解的子问题后，在「归」的过程中自然顺其自然地解决了最开始的问题。

**递归算法通用解决思路**

我们在上面仔细剖析了什么是递归，可以发现递归有以下两个特点

1. 一个问题可以分解成具有**相同解决思路**的子问题，子子问题，换句话说这些问题都**能调用同一个函数**
2. 经过层层分解的子问题最后一定是一个不能再分解的固定值（即终止条件），如果没有的话，就无穷无尽地分解子问题了，问题显示是无解的。

所以解递归的关键问题在于我们首先需要根据以上递归的两个特点判断题目是否可以用递归来解。

经过判断可以用递归后，接下来我们就来看看用递归阶梯的基本套路（四步曲）：

1. 先定义一个函数，**明确这个函数的功能**，由于递归的特点是问题和子问题都会调用函数自身，所以这个函数的功能一旦确定了，之后只要寻找问题和子问题的递归关系即可
2. 接下来寻找问题与子问题的关系（及递推公式），这样由于问题和子问题具有**相同解决思路**，这样子问题调用步骤一定义好的函数，问题即可解决。所谓的关系最好能用一个公式表示出来，比如f(n)=n*f(n-1)这样，如果暂时无法得出明确的公式，用伪代码表示也是可以的，发现递推关系后，**要寻找不可再分解的子问题的解**，即（临界条件），确保子问题不会无限分解下去。由于第一步我们已经定义了这个函数的功能，所以当问题拆分成子问题时，子问题可以调用步骤1定义的函数，符合递归的条件。
3. 将第二步的递推公式用代码表示出来补存到步骤1定义的函数中
4. 最后也是很关键的一步，根据问题与子问题的关系，推导出时间复杂度，如果发现递归时，时间复杂度不可接受，则需**转换思路对其进行改造**，看下是否有更靠谱的解法

